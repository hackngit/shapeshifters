/**
 * Click or type any key to restart drawing and use a new randomized vector field and color scheme!
 * Drawing is slow, so be patient if you want to see a nicer image.
 **/
//variables
var objs = []; //holds all the particle objects
var amount = 100; //how many particles there are
var cycles = 20; //cycles to calculate per frame
var backgroundColor; //color of the background
var angleFactor = 10.0; //ampitude of angle of sticks
var zSpeed = abs(0.00001); //z (in noise) moving speed
var seed; //noise seed
var zPos; //z position
var cycleCount = 0; //counts cycles
var velNoiseZoom = 350; //zoom in vector field noise (higher = more zoomed in)
var colNoiseZoom = 200; //noise zoom for color of particles
var particleSpeed = 0.4; //particle speed
var prctSize = 1; //particle size
var colorValMap = [0.25, 0.75]; //color noise field value map range (origin range)
var prtcAlpha = 4; //alpha value for particles
var noiseParams = [3, 0.5]; //noise parameters
var phi = 0.6180339887498948; //phi minus one
var respawnCounter; //counts creation of pixels
var pixelPos;
var pixelNum; //amount of pixels there are
var colorScheme; //current color scheme

//define function for getting the value of a position
var getVal = function(xPos, yPos, z, zoom) {
  //put the formula here - noise
  return noise(xPos / zoom, yPos / zoom, z);
};

//gradient color map
var colorSchemes = [
  {
    bkg: color(0, 0, 0),
    colors: [
      {
        col: color(0, 21, 89),
        val: 0
      },
      {
        col: color(27, 108, 194),
        val: 0.39
      },
      {
        col: color(89, 189, 255),
        val: 0.45
      },
      {
        col: color(255, 243, 23),
        val: 0.47
      },
      {
        col: color(0, 179, 0),
        val: 0.50
      },
      {
        col: color(0, 143, 57),
        val: 0.60
      },
      {
        col: color(138, 138, 138),
        val: 0.64
      },
      {
        col: color(206, 215, 224),
        val: 0.73
      },
      {
        col: color(242, 242, 242),
        val: 1
      }
    ]
},
  {
    bkg: color(255, 255, 255),
    colors: [
      {
        col: color(0, 0, 0),
        val: 0
      },
      {
        col: color(129, 58, 150),
        val: 0.2
      },
      {
        col: color(255, 0, 38),
        val: 0.55
      },
      {
        col: color(140, 0, 145),
        val: 1
      }
    ]
},
  /*{
    bkg: color(128, 128, 128),
    colors: [
      {
        col: color(0, 0, 0),
        val: 0
      },
      {
        col: color(0, 0, 0),
        val: 0.43
      },
      {
        col: color(38, 255, 0),
        val: 0.45
      },
      {
        col: color(255, 255, 255),
        val: 0.47
      },
      {
        col: color(255, 255, 255),
        val: 1
      }
    ]
},*/
  {
    bkg: color(0, 0, 0),
    colors: [
      {
        col: color(156, 119, 59),
        val: 0
      },
      {
        col: color(255, 184, 92),
        val: 0.4
      },
      {
        col: color(93, 204, 53),
        val: 0.45
      },
      {
        col: color(42, 232, 67),
        val: 0.5
      },
      {
        col: color(0, 255, 179),
        val: 0.55
      },
      {
        col: color(158, 66, 0),
        val: 0.6
      },
      {
        col: color(255, 255, 255),
        val: 1
      }
    ]
},
  {
    bkg: color(0, 0, 0),
    colors: [
      {
        col: color(255, 245, 255),
        val: 0
      },
      {
        col: color(225, 255, 0),
        val: 0.49
      },
      {
        col: color(0, 204, 255),
        val: 0.51
      },
      {
        col: color(255, 255, 255),
        val: 1
      }
    ]
},
  {
    bkg: color(0, 0, 0),
    colors: [
      {
        col: color(115, 255, 164),
        val: 0
      },
      {
        col: color(68, 255, 0),
        val: 0.35
      },
      {
        col: color(0, 60, 255),
        val: 0.41
      },
      {
        col: color(14, 207, 0),
        val: 1
      }
    ]
},
  {
    bkg: color(255, 255, 255),
    colors: [
      {
        col: color(181, 72, 0),
        val: 0
      },
      {
        col: color(153, 144, 66),
        val: 0.35
      },
      {
        col: color(161, 55, 94),
        val: 0.41
      },
      {
        col: color(235, 0, 0),
        val: 1
      }
    ]
},
];

//correct color lerp from here: https://www.khanacademy.org/computer-programming/correctlerpcolors-and-lerpcolor-comparison/5591262186307584
var correctColorChannelLerp = function(c1, c2, factor) {
  return floor(sqrt(lerp(sq(c1), sq(c2), factor)));
};
var correctLerpColors = function(c1, c2, factor) {
  return (prtcAlpha << 24) | (correctColorChannelLerp((c1 >> 16) & 0xFF, (c2 >> 16) & 0xFF, factor) << 16) | (correctColorChannelLerp((c1 >> 8) & 0xFF, (c2 >> 8) & 0xFF, factor) << 8) | correctColorChannelLerp(c1 & 0xFF, c2 & 0xFF, factor);
};
//cosine color lerping
var cosFactorMod = function(fac) {
  return (cos(fac * 180 + 180) + 1) * 0.5;
};
//linear
var linFactorMod = function(fac) {
  //changes nothing
  return fac;
};
//multi color gradient
var multiColorGradient = function(colors, factorModFunction, factor) {
  factor = constrain(factor, 0, 1);
  var colorIndex = colors.length - 2;
  while (factor < colors[colorIndex].val) {
    colorIndex--;
  }
  return correctLerpColors(colors[colorIndex].col, colors[colorIndex + 1].col, factorModFunction(norm(factor, colors[colorIndex].val, colors[colorIndex + 1].val)));
};

//define partcle object
var prtc = function() {
  this.position = new PVector(0, 0); //position
  this.velocity = new PVector(0, 0); //velocity (direction)
  this.col = 0; //color of this partile, is set with position

  //setup this particle
  this.reset();
};

//add a draw method to the partcle object
prtc.prototype.draw = function() {
  //set color
  stroke(this.col);

  //draw point at position
  point(this.position.x, this.position.y);
};

//add a calculate method to the partcle object
prtc.prototype.calc = function() {
  //get noise/formula value
  var val = getVal(this.position.x, this.position.y, zPos, velNoiseZoom);

  //calculate position by adding the velocity vector to the speed vector
  this.position.add(sin(val * angleFactor) * particleSpeed, cos(val * angleFactor) * particleSpeed);
};

//add a reset method to the partcle object
prtc.prototype.reset = function() {
  //calculate unique position
  pixelPos = pixelNum * ((respawnCounter * phi) % 1);
  //pixelPos = respawnCounter % pixelNum;

  //set position with pixel position
  //this.position.set(random(width), random(height));
  this.position.set(pixelPos % width, floor(pixelPos / width));

  //set color with position, choose from palette
  this.col = multiColorGradient(colorScheme.colors, cosFactorMod, norm(getVal(this.position.x, this.position.y, seed, colNoiseZoom), colorValMap[0], colorValMap[1]));
  
  //increment counter
  respawnCounter++;
};

//add a check method to the partcle object to reset the particles when necessary
prtc.prototype.check = function() {
  //check position (if out of screen)
  if (this.position.x > width || this.position.x < 0 || this.position.y > height || this.position.y < 0) {
    //reset if out of screen
    this.reset();
  }
};

//sets up
var setupDraw = function() {
  //random noise seed
  seed = random(-1000000000, 1000000000);

  //init position with seed
  zPos = seed + 10;

  //reset counter
  respawnCounter = 0;

  //pick random color scheme with seed
  colorScheme = colorSchemes[colorSchemes.length === 1 ? 0 : floor(abs(seed) % colorSchemes.length)];

  //draw background
  background(colorScheme.bkg);
  
  //get pixel amount
  pixelNum = width * height;

  //fill array with particles and setup
  for (var i = 0; i < amount; i++) {
    //make new particle object
    objs[i] = new prtc();
  }
};

void setup() {
  size(displayWidth,displayHeight, P2D);
  //windowWidth, windowHeight
  
  //setup
  noiseDetail(noiseParams[0], noiseParams[1]);
  frameRate(60);
  strokeWeight(prctSize);
  smooth();

  //setup particles and other stuff
  setupDraw();
};

//start draw
void draw() {
  //do cycles
  for (var c = 0; c < cycles; ++c) {
    //increment the z position
    zPos = seed + cycleCount * zSpeed;

    //go through all particles
    for (var i = 0; i < amount; ++i) {
      //check the position and reset if necessary
      objs[i].check();

      //calc the position
      objs[i].calc();

      //draw
      objs[i].draw();
    }
  }

  //count cycle
  cycleCount++;
};

//click and key callback
void mouseClicked() {
  //reset draw
  setupDraw();
};
void keyTyped() {
  //reset draw
  setupDraw();
};